* Rate (
    | Rational64
    | None
)

* Mixer {
    ? n m
    smpRate : RateOf : smp
    par {
        smp {
            RateHere
        }
    }
}

* Bst (
    | Empty
    | Node (
        * value : Num
        * left : Bst
        * right : Bst
    )
)

{
   bst : Bst : (
        7 (
            3 (
                2 5 (
                    4 6
                )
            )
            9 (
                8 10
            )
        )
    )

    bst : Bst : 7 (3 (2 5 (4 6)) 9 (8 10))
}

? in : Bst
[
    : Match : in Empty
    ...
|
    : Match : in Node
    ... in.value
|
    ...
]

* ShapeId
* CircleId : ShapeId
* RectangleId : ShapeId
* PolygonId : ShapeId

* ShapeId (
    | CircleId
    | RectangleId
)

* Email { address : String}
* EmailAddress : String
email : Email : "jerro@jerro.ch"
emails : #Email : "dan@jerro.ch" email

* ToEmailAddress {
    ? s : String
    [
        : Regex.Match : s "^\S+@\S+\.\S+$"
        ! email : Error : "No Match"
    |
        ! email : Email : s
    ]
}

emailOk : ToMailAddress : "jerro@jerro.ch"
emailNone : ToEmailAddress : "Jerro"

* ToEmailAddress {
    ? s : String
    error [
        : Regex.Match : s "^\S+@\S+\.\S+$"
        ! Error : "No Match"
    email |
        ! Email : s
    ]
}

{
    ToEmailAddress.s : "jerro@jerro.ch"
    [
        print ToEmailAddress?error
    |
        print ToEmailAddress?email
    ]
}

error email : ToMailAddress : "jerro@jerro.ch"
[
    ... error ...
|
    ... email ...
]

* Square {
    ? x
    ! x*x
}

* Sum {
    ? x : _*Num
    ! Fold : x 0 Add
}

* SomeObj {
    Func : (Sum : Square)
}

* AddingCalculator {
    ? in
    ! in+1
}

* LoggingCalculator {
    ? in Func
    log : "input: ",in
    out : Func : in
    log : "output: ",out
    ! out
}

* Add42 : (NumAdd : 42)

* Add42 : NumAdd {
    b : 42
}

a : 1 2 4 50 5423 3403 24 0
-- i : 0
{
    b@i : (a@i + a@(i+1)) / 2
    -- i : i + 1
}

a : 1 2 4 50 5423 3403 24 0
n : Size : a
b : (a@0..(n-2) + a@1..(n-1)) / 2

* List (
    ? T
    -- Stands for Union Cases
    | End
    | Node : {
        * val : T
        * next : List : T -- a cycle
    }
)

* Cycle (
    ? T
    | Node : {
        * val : T
        * next : Node
    }
)
-- Example
cycle : cycle:Int32 : (1 (2 (3 cycle)))

* InsertAfter {
    ?T
    ?c : List:T
    ?e : T
    { c : Node & e < c.val
        co : List:T: cr.val : cr.next
    }
    i.next : e i.next
    ! c : Cycle:T
}

* List (
    ?T
    |Empty
    |Node (
        *val : T
        *next : List:T
    )
)


* BTree (
    ?T
    | Empty
    | Node (
        * val : T
        * left : BTree:T
        * right : BTree:T
    )
)

l : (List:Int32) : 1 2 3 4

l2 : 0 l

l3 : l 5

{ l : Node
| l.val <
    o : 


}

-- Recursive List
list : (SList:Int32).Start : (1 (2 (3 list)))
list : Start : 1 2 3 list

* Graph (
    * List ()
    | Empty
    | Node (
        * val : String
        * others : List
    )
)

* Ref (
    ? T
)

* Timeline

* File {
    ?Element : Obj
    Reader.setPos [  -- Reader is a type, hence starts with capital letter, ".setPos" is optional
        ?pos : Position
    ]
    {
        Reader.read [
            !out : Element
        ]
        write [
            ?in : Element
        ]
    }
    clear [
    ]
}

*AudioFile : File:Audio.Sample
-- This implicitly makes AudioFile{*Element} from File{?Element}
Element : AudioFile.Element
-- 

--  Free file reader use:
* FileRenderer {
    file_ : File : Audio.Sample
    file.write : sin : 0.0 .. 2*Math.pi .. 0.02*Math.pi
    _firstReader : file.Reader
    _firstReader.setPos 10
    _secondReader : file.Reader
    _secondReader.setPos 20
  

}


-- File reader signature:
*File.Reader {
    *setPos [
        ?pos : Position
    ]
    *read {
        !out : Element

    }
}

-- generic module
*Sp (
    ?Sample
)

*Audio (
    *Sample : (Float32)  -- Only compatible with Sample. Use 'fl : Float32 : smp' to get the float 
    *Sp : Sp:Sample  -- specific Sp module

)