' Any data or object or type.
*ANY (
    *Eq= {
    }
    *Neq<> {
    }
    *String {
    }
)

' Just a bunch of 'OBJ'.
*MOD ()

' The base type for all data. May contain functions for the type itself as well, hence its a 'MOD'.
*DATA : MOD (
    *FromBytes {  ' Unsafe conversion from of raw data.
        ?in : DATA
        ?out : DATA
    }
)

' Can be a function or an stateful object.
*OBJ : ANY {
}

' Dangerous object that can register an error. Errors are passed along the syntax tree as long as unchecked.
' Functions that do not check all there dangerous outputs must be defined as dangerous themselves.
' On an error, function outputs are set to the base value of its type.
*EOBJ : OBJ {
}

*CHECK {
    ?data
    !result
}

' To get a handle of an object:
'   o : .obj
*HANDLE : DATA (
)

' Array definition:
'   matrix : ARRAY NUM (3 3)
' with shortcut
'   matrix : 3#3#NUM
*ARRAY# (
    ?T
    ?size : d#UINT

    *Get@ : EOBJ {
        ?array
        ?at
        !value : T  ' On error value is T's base value.
    }
    ' The set operator is a shortcut to make
    '   array : SET : array index element
    ' look like an inplace operation
    '   array@index : element
    ' with re-assignment of signal name "array"
    *Set@: : EOBJ {  ' array@index : x
        ?array
        ?index : d#UINT
        ?element : T
        !array
    }
    *Concat, {
        ?a
        ?b
        ?c
    }
)

*STRING (
    *Concat, {
        ?a
        ?b
        !c
    }
    *Len { 
        ?s
    }
)

'( Example:
*Matrix3D : ARRAY : 3 (ARRAY 3 FLOAT32)
' With special syntax:
*Matrix3D : 3#3#FLOAT32
' Access:
m : Matrix3D : (1 0 0) (0 1 0) (0 0 1)
m@1@1 : 2  ' m becomes a new matrix
m.T

*OpenArrayFunction {
    ?arr : ##FLOAT32
    { e : arr@i  ' Iterate all
        { f : arr@j

        }
    }
    ?oldArr : m#n#FLOAT32
    newArr : m#n#FLOAT32
    { e f : arr@i@j oldArr@i@j
        f : e + 1
    }
    { e : oldArr@i@j
    & f : newArr@i@j
        f : e + 1
    }
}
)'

*BOOL (
    |True
    |False

    *And&& {}
    
    *Or|| {}
    
    *Xor^^ {} ' Same as NEQ<> but less binding.
)

*NUM (
    ' We define fields here that would make it possible to implement arbitrary length/precision numbers
    .numerator (  ' Dot ('.') definitions can only be accessed from functions within NUM or types derived from NUM.
        *negative
        *size
    )
    .exponent (
        *size
        *neg
    )
    .denominator (  ' Base value is 1 for this.
        *size
    )

    ' Result will have the fixed size of the input with the bigger range.
    ' Wrapping for integers,
    ' saturating for floats (+-infinity),
    ' not allowed for generic numbers and not statically defined or statically different denominators.
    *Add+ {
        ?a
        ?b
        !c
    }
    *Sub- {
    }

    ' The carry bit is part of the result. The result grows or shrinks dynamically with the needed size.
    ' Not allowed for not statically defined or statically different denominators.
    *AddExt++ {
        ?a
        ?b
        !c
    }
    *SubExt-- { ' The carry bit is part of the result. The result grows or shrinks dynamically with the needed size.
        ?a
        ?b
        !c
    }

    ' Result will have the fixed size of the input with the bigger range.
    *Mul* {

    }
    ' The results numerator size is the sum of the input numerator sizes.
    *MulExt** { 

    }

    ' Result will have the fixed size of the input with the bigger range.
    *Div/ : EOBJ {
    }
    *Rem\ : EOBJ {
    }
    ' 
    *DivExt// : EOBJ {
    }

    ' out = in * 2^n
    *Shift<< {
    }

    ' Can be used from a derived data like 'someInt32Number : INT32.SatRound : someFloat64number'
    *SatRound {
    }
    *SatTrunc {
    }
    *WrapRound {
    }
    *WrapTrunc {
    }
)
*INT : NUM (
    .denominator : 1
    .exponent : 0
)
*INT8
*INT16
*INT32 : INT (
    .numerator (
        .size : 32
    )
)
*INT64
*UINT
*UINT8
*UINT16
*UINT32
*UINT64
*FLOAT32
*FLOAT64

'( More functions for NUM could be defined in a derived type.
*NumExt : NUM (
    *Reduce {
        ' numerator/denominator/... can be accessed from here.
    }
) 
)'

*SET (
    (
        ?Accessor  ' Must have finite (small) number of possible values (Enumeration)
    |
        ?n : UINT
    )

    *And& {

    }
    *Or| {

    }
    *Xor^ {

    }

    *Shift<< {
        ?in
        ?n
        !out
    }
    *Rotate<<< {
    }
)
*SET8
*SET16
*SET32
*SET64

*INT : NUM (
    .denominator : 1
    .exponent : 0
)

*INT32 : INT (
    .numerator (
        .size : 32
    )
)

' DATA type that may do dynamic memory management using pointers.
' But pointers are always private to the DYNAMIC.
*DYNAMIC (
)

