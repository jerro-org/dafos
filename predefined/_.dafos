' Any data or object or type.
*ANY : (
    *Eq= {
    }
    *Neq<> {
    }
    *String {
    }
)

' Just a bunch of 'OBJ'.
*MOD : ()

' The base type for all data. May contain functions for the type itself as well, hence its a 'MOD'.
*DATA : MOD (
    *Size {} ' in bits
    *Length {} ' in bytes
)

' Convertable to all other data with same size.
*BITS : DATA (
    ?n : UINT
)
*BITS8 : BITS:8
' ...

' Can be a function or an stateful object.
*OBJ : ANY {
}

' Dangerous object that can register errors for its outputs. Errors are passed along the syntax tree as long as unchecked.
' Functions that do not check all there dangerous outputs must be defined as dangerous themselves.
' On an error, function outputs are set to the base value of its type.
*EOBJ : OBJ {
}

*CHECK : {
    ?data
    !result
}

' FIXME Do we actually need it for data?)
' To get a handle of any (data or) object:
'   o : .obj
' This is also possible, before the object is defined to access properties of the object that are known, before.
' Eg. type of object and (RT-)connection properties (sample rate, etc.).
*HANDLE. : DATA (
    ?T
    *Type {
        ?h
        !T
    }
)

' Array definition:
'   matrix : ARRAY : NUM (3 3)
' with shortcut
'   matrix : 3#3#NUM
*ARRAY# : (
    ?T
    ?size : d#UINT

    *Get@ : EOBJ {
        ?array
        ?at
        !value : T  ' On error value is T's base value.
    }
    ' The set operator is a shortcut to make
    '   array : SET : array index element
    ' look like an inplace operation
    '   array@index : element
    ' with re-assignment of signal name "array"
    *Set@: : EOBJ {  ' array@index : x
        ?array
        ?index : d#UINT
        ?element : T
        !array
    }
    *Concat, : {
        ?a
        ?b
        ?c
    }
)

*STRING : (
    *Concat, : {
        ?a
        ?b
        !c
    }
    *Len : {
        ?s
    }
)

'( Example:
*Matrix3D : ARRAY : 3 (ARRAY 3 FLOAT32)
' With special syntax:
*Matrix3D : 3#3#FLOAT32
' Access:
m : Matrix3D : (1 0 0) (0 1 0) (0 0 1)
m@1@1 : 2  ' m becomes a new matrix
m.T

*OpenArrayFunction : {
    ?arr : ##FLOAT32
    { e : arr@i  ' Iterate all
        { f : arr@j

        }
    }
    ?oldArr : m#n#FLOAT32
    newArr : m#n#FLOAT32
    { e f : arr@i@j oldArr@i@j
        f : e + 1
    }
    { e : oldArr@i@j
    & f : newArr@i@j
        f : e + 1
    }
    { e : oldArr@i@j; f : newArr@i@j
        f : e + 1
    }

    ' line breaking
    signal : Fun1 : Fun2 : Fun3 
    : Fun4 :
}
)'

*BOOL : (
    |True
    |False

    *And&& : {}
    
    *Or|| : {}
    
    *Xor^^ : {} ' Same as NEQ<> but less binding.
)

' NUM is a generic number.
' It is designed to allow to keep the precision and length after the four basic operations +, -, *, and /.
*NUM : (
    *Sgn : (
        |Positive
        |Negative
    )

    ' We define fields here that make it possible to implement arbitrary length/precision numbers.
    .numerator : INT (  ' Dot ('.') definitions can only be accessed from functions within NUM or types derived from NUM.
        *size : UINT ' stored size
        *sign : Sign
    )
    .exponent : INT (
        *sign : Sign ' stored size
        *size : UINT
    )
    .denominator : UINT (  ' Base value is 1 for this.
        *size : UINT ' stored size
    )

    ' Result will have the fixed size of the input with the bigger range.
    ' If one of the inputs has 
    ' Wrapping for integers, saturating for floats (+-infinity).
    *Add+ : {
        ?a
        ?b
        !c
    }
    *Sub- : {
    }

    ' The carry bit is part of the result. The result grows or shrinks dynamically with the needed size.
    ' Not allowed for not statically defined or statically different denominators.
    *AddExt++ : {
        ?a
        ?b
        !c
    }
    *SubExt-- : { ' The carry bit is part of the result. The result grows or shrinks dynamically with the needed size.
        ?a
        ?b
        !c
    }

    ' Result will have the fixed size of the input with the bigger range.
    *Mul* : {

    }
    ' The results numerator size is the sum of the input numerator sizes.
    *MulExt** : { 

    }

    ' Result will have the fixed size of the input with the bigger range.
    *Div/ : EOBJ {
    }
    *Rem\ : EOBJ {
    }
    ' 
    *DivExt// : EOBJ {
    }

    ' out = in * 2^n
    *Shift<< : {
    }

    ' Check if the actual data in the input number would fit into this type.
    *CheckRange : {
        ?in
        !fits : BOOL
    }
    *CheckPrecision : {
        ?in : NUM
        !fits : BOOL
    }
    ' Can be used from a derived data like 'someInt32Number : INT32.SatRound : arbitraryNumber'
    *SatRound : {
        ?in
        !out
    }
    *SatTrunc : {
    }
    *WrapRound : {
    }
    *WrapTrunc : {
    }
    *Numerator : {
    }
    *Denominator : {
    }
    *Exponent : {
    }
    *Size : {
    }
    *StoredSize : {
    }
    *Sign : {
        ?in
        !out : Sgn
    }
    *Absolute : {
    }
)
*INT : NUM (
    .denominator : 1
    .exponent : 0
)
*INT8
*INT16
*INT32 : INT (
    .numerator (
        .size : 32
    )
)
*INT64
*UINT
*UINT8
*UINT16
*UINT32
*UINT64
*UINT128
*FLOAT : NUM (.denominator : 1)
*FLOAT16 : FLOAT (.numerator.size: 11; .exponent.size: 5)
*FLOAT32 : FLOAT (.numerator.size: 24; .exponetn.size: 8)
*FLOAT64 : FLOAT (.numerator.size: 53; .exponent.size: 11)
*FLOAT128
*FIX
*FIX8
*FIX16
*FIX32
*FIX64
*UFIX
*UFIX8
*UFIX16
*UFIX64
*RATIONAL : NUM (.exponent : 0)
*RATIONAL16 : RATIONAL (.numerator.size : 8; denominator.size : 8)
*RATIONAL32
*RATIONAL64
*RATIONAL128

'( Define more concrete types:
*Fix32q24 : Fix32 (.exponent : -24)
*Rational64 : RATIONAL (.numerator(.size : 32); .denominator(.size : 32))
)'

'( More functions for NUM could be defined in a derived type.
*NumExt : NUM (
    *Reduce {
        ' numerator/denominator/... can be accessed from here.
    }
) 
)'

*SET : (
    (
        ?Accessor  ' Must have finite (small) number of possible values (Enumeration)
    |
        ?n : UINT
    )

    *And& {

    }
    *Or| {

    }
    *Xor^ {

    }

    *Shift<< {
        ?in
        ?n
        !out
    }
    *Rotate<<< {
    }
)
*SET8
*SET16
*SET32
*SET64

*INT : NUM (
    .denominator : 1
    .exponent : 0
)

*INT32 : INT (
    .numerator (
        .size : 32
    )
)

' Pointer data type with restricted usage.
*PTR^ : (
    ?T
    *Ref^_ : {  ' Real pseudo definition. '^' before identifier, operator cannot be overwritten.
    }
    *Deref_^ : {  ' Real pseudo definition. '^' after identifier, operator cannot be overwritten.
    }
)
' The pointer notation is also used to define a type parameter as the type itself, not its instance:
' .listOfFunctions : List:OBJ

' DATA type that may do dynamic memory management using pointers.
' But pointers are always private to the DYNAMIC.
*DYNAMIC : (
)

