
*RATE (
    |VAR
    |CONST {
        *val : RATIONAL64
        *source : 
    }
)

*SIZE : UINT64

*CLOCK : (
    |SYS
    |DEV : HANDLE
)

*ANY (
    -size : SIZE

    *EQ= {}
    *NEQ<> {}
    *TOSTRING {}
)


*OBJ {  ' Can be a function or an stateful object.
    -rate : RATE
    -clock : (SYSTEM)
}

' The base type for all data. 
*DATA (
    *FromBytes {  ' Unsafe conversion from of raw data.
        ?in : DATA
        ?out : DATA
    }
)

*HANDLE (

)

' Type with special syntax
*ARRAY# (
    ?T
    ?size : UINT#d
    *GET@ {
        ?array
        ?at
        !element
    }
    *SET@: {
        ?array
        ?index
        ?element
        !array
    }
    *CONCAT, {
        ?a
        ?b
        ?c
    }
    *LEN {
        ?array
        !lenghts : UINT#d
    }
)

*STRING (
    *CONCAT, {
        ?a
        ?b
        !c
    }
    *LEN { 
        ?array
    }
)

'( Example:
*Matrix3D : ARRAY : 3 (ARRAY 3 FLOAT32)
' With special syntax:
*Matrix3D : 3#3#FLOAT32
' Access:
m : Matrix3D : (1 0 0) (0 1 0) (0 0 1)
m@1@1 : 2  ' m becomes a new matrix
m.ElementType

*OpenArrayFunction {
    ?arr : n#m#FLOAT32
    { i : 0..n  ' Iterate range
        { j : 0..m

        }
    }
}
)'

*BOOL (
    |TRUE
    |FALSE

    *AND&& {}
    
    *OR|| {}
    
    *XOR^^ {} ' Same as NEQ<> but less binding.
)

*NUM (
    .numerator (  ' Dot ('.') definitions can only be accessed from functions within NUM or types derived from NUM.
        *size
        *negative
    )
    .denominator (
        *size
    )
    .exponent (
        *size
        *neg
    )

    *ADDWRAP+ {
        ?a
        ?b
        !c
    }
    *ADDEXT++ { ' The carry bit is part of the result. The result grows or shrinks dynamically with the needed size.
        ?a
        ?b
        !c
    }
    *MULWRAP {

    }
    *MULEXT** { ' The results mantissa is twice as 

    }

    *DIVTRUNC/
    *DIVEXT//
    *REM\
    '' ...

    *SAT {
    }
    *CHECK {  ' Check if any error flag was set during computation of the number in this scope.
    }
)

'( More functions for NUM could be defined in a derived type.
*NumExt : NUM (
    *Reduce {
        ' numerator/denominator/... can be accessed from here.
    }
) 
)'

*SET (
    (
        ?Accessor  ' Must have finite (small) number of possible values (Enumeration)
    |
        ?n : UINT
    )

    AND*
    OR+
    XOR^
)

*INT : NUM (
    .denominator : 1
    .exponent : 0
)

*INT32 : INT (
    .numerator (
        .size : 32
    )
)

'( Do we need references. Maybe use more heavyweight HANDLES for something that should be used as seldom as possible.
*REF (
    *GET {
        ?_any : ANY
        !ref : REF
    }
)    
)'

