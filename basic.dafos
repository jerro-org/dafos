*ANY (
    *EQ= {}
    *NEQ<> {}
    *TOSTRING {}
)

*OBJ {  ' Can be a function or an stateful object.
    *SIZE {
        ? object
        ! size
    }
}
*DATA (
    *FromBytes {  ' Unsafe converstion from of raw data.
        ?in : DATA
        ?out : DATA
    }
)

' Type with special syntax
*ARRAY# (
    ?T
    ?size : UINT#_
    *GET@ {
        ?array
        ?at
        !element
    }
    *SET@: {
        ?array
        ?index
        ?element
        !array
    }
    *CONCAT, {
        ?a
        ?b
        ?c
    }
    *LEN {
        ?array
        !lenghts : UINT#_
    }
)

*STRING (
    *CONCAT, {
        ?a
        ?b
        !c
    }
    *LEN { 
        ?array
    }
)

'( Example:
*Matrix3D : ARRAY : 3 (ARRAY 3 FLOAT32)
' With special syntax:
*Matrix3D : 3#3#FLOAT32
' Access:
m : Matrix3D : (1 0 0) (0 1 0) (0 0 1)
m@1@1 : 2  ' m becomes a new matrix
m.ElementType

*OpenArrayFunction {
    ?arr : n#m#FLOAT32
    { i : 0..n  ' Iterate range
        { j : 0..m

        }
    }
}
)'

*BOOL (
    |TRUE
    |FALSE
    *AND&& ()
    *OR|| ()
    *XOR^^  ' Same as NEQ<> but less binding.
)

*NUM (
    .numerator (  ' . definitions can only be accessed from functions within NUM or types derived from NUM.
        *size
        *negative
    )
    .denominator (
        *size
    )
    .exponent (
        *size
        *neg
    )

    *ADDWRAP+ {
        ?a
        ?b
        !c
    }
    *ADDEXT++ {
        ?a
        ?b
        !c
    }
    *DIVTRUNC/
    *DIVEXT//
    *REM\
    '' ...
)

'( More functions for NUM
*NumExt : NUM (
    *Reduce {
        ' numerator/denominator/... can be accessed from here.
    }
) 
)'

*SET (
    (
        ?Accessor  ' Must have finite (small) number of possible values (Enumeration)
    |
        ?n : UINT
    )

    AND*
    OR+
    XOR^
)

*INT : NUM (
    .denominator : 1
    .exponent : 0
)

*INT32 : INT (
    .numerator (
        .size : 32
    )
)

*REF (
    *GET {
        ?_any : ANY
        !ref : REF
    }
)
